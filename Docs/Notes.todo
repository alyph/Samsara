

TODO:

	✔	directive parsing revamp (high level tokenizing) @done (16-10-11 21:52)
	✔	able to replace \# \{ @done (16-10-11 21:52)
	✔	parse directive expr @done (16-10-12 22:43)
	✔	parse data binding, text binding @done (16-10-13 22:05)
	✔	lexer @done (16-10-14 22:51)
	✔	fix data binding regex, likely will need split to open binding { and close } @done (16-10-15 15:56)
	✔	new function throw exception, need try catch @done (16-10-15 15:56)
	✔	directive config @done (16-10-15 22:04)
	☐	clause group, content (what happens if they are "")
	☐	escaped blah, doesn't need 3 different token types, just merge them all.

	☐	element binding (property, attribute, event)
	☐	runtime instance hookup (traverse path, binding, directive instances)

	☐	observable object (passive style)
	☐	component wise <script> (data object prototype)

	☐	clean up template and element to use component 

	☐	any error logging needed.

-----------------------------------------------------------------------

	☐	route init() (should renamed to loaded()), add all objects to the map, then call loaded() on them.
	☐	opportunity based combat actions

	☐	convert world update to use the LatentUpdater
		
	☐	add sprites ref func $img()
	☐	replace isatlocal with partylocal : local, since it s exclusive, or make isatlocal exclusive
	☐	change locale to locale within relationship to a more generic relationship and fix the find potential travel origin to check single connection special case rather than within relation
	☐	objects set by find references should have $ref set to true (?)
	☐	image setting in template


	✔	basic scene layout @done (14-09-17 21:10)
	✔	sprites positioning @done (14-09-17 21:10)

	✔	create all locals @done (14-04-01 22:54)
	✔	activities @done (14-04-01 22:54)
	✔	states @done (14-04-01 22:54)
	✔	quests @done (14-04-01 22:54)
	✔	fix quest.goal parsing code @done (14-04-01 23:15)
	✔	update definition code @done (14-04-01 22:54)

	✔	make $p more friendly just put function in param list and make it $ref @done (14-04-01 22:54)
	✔	hasExplored func (can just return false for now) @done (14-04-02 20:47)
	✔	getPotentialTravelOrigins @done (14-04-02 21:39)
	✔	Player.beginPlanPhase, UI, interaction @done (14-04-05 00:14)

	✔	activity merge @done (14-04-05 00:14)

UI:
	☐	may get rid of addchild concept so it doesn't matter where in the chain addchild is called...
	☐	get rid of game query

Future:
	☐	better expression($e) imp
	☐	hasExplored real imp
	☐	upgrade to latest head.js


behavior
task
action
command, operation, procedure

intention/goal/task: melee, ranged, support, withdraw, flee
behaviors: modifiers to the ongoing task, how to achieve the goal/intention: band, leader, lonewolf



super - sub   UI element vs. the elements inside template
outer - inner direct parent-child relationship between 2 elements
parent - child two elements linked as parent child and also in same heiarchy


this.handler("fooo");

this.callback("bar", handler);
this.callback("bar").call(params);

{
		div:
		{
				subdiv: {},
				subdiv: {}
		}
}




Other Nodes:
 
Rosvel March:
{
	Local:
	{
		Desc: "Wild of Rosvel"
	},

	Region:
	{

	}

}


exploration:
{
	params:
	[
		region : region
	]

	goals:
	[
		"explored region.areas"
	]
}

explored
{
	params:
	[
		area : area
	]
}


explore:
{
	params:
	{
		area : area
	}

	effects:
	[
		"explored"
		area : "area"
	]

	preconditions
	[
		"at local"
	]
}

visit:
{
	params:
	{
		person : person
	}

	preconditions:
	[
		"at person.area"
	]
}

travel:
{
	params:
	{
		from : local
		to : local
	}

	satisfies:
	{
		precondition: "at",
		from : "local.adjacents"
		to : "local"
		cost : travelcost
	}

	effects
	[
		at(to) : true | from : local.adjacents, to : local
	]

	restrictions
	{
		from : to.adjacents
	}
	
	preconditions:
	[
		at(from) : true
	]
}

Plan(goal, actions, context)
{
	goal --> states ? statements?
	open.push(goal)
	visited.push(goal) 

	while (open not empty)
	{
		states = open.pop()
		states.eval(context) returns true --> finish

		foreach state in states  find actions that satisfies the state (effects -> state) actions.findActions(state, context) --> potential actions that can solve the problem
			accept action whose effects making at least one of the state true --> such states will be removed from the set
			reject action if effects affects but does not satisfy one of the state
				or preconditions contradict one of the state, related preconditions must be merged

			* effect.satisfies(state) ->> state is necessary condition for effect,  effect is sufficient condition for state
			** precondition.contradicts(state) -> reject
			*** ?? what if state has conjuction --> merge? => no precondition will be merged with existing condition as long as not completely contradictory

		new node excludes states achieved by the action 
			contains states unchanged, 
			and action's preconditions
			record action and its cost

		find new node in visited,
			if found, compare cost, pop and re-push if cost is lower with action and previous node updated
	}
}